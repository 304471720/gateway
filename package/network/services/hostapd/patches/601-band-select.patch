--- a/hostapd/Makefile
+++ b/hostapd/Makefile
@@ -839,7 +839,8 @@ OBJS += ../src/ap/ap_list.o
 OBJS += ../src/ap/ieee802_11.o
 OBJS += ../src/ap/hw_features.o
 OBJS += ../src/ap/dfs.o
-CFLAGS += -DNEED_AP_MLME
+OBJS += ../src/ap/band_select.o
+CFLAGS += -DNEED_AP_MLME -DDUAL_BAND_SELECT
 endif
 ifdef CONFIG_IEEE80211N
 OBJS += ../src/ap/ieee802_11_ht.o
--- a/src/ap/ap_config.h
+++ b/src/ap/ap_config.h
@@ -207,6 +207,23 @@ struct hostapd_nai_realm_data {
 	} eap_method[MAX_NAI_EAP_METHODS];
 };
 
+#ifdef DUAL_BAND_SELECT
+typedef struct s_band_select{
+	u8 band_select_enable;	/*Default is disable*/
+	u8 probe_cycle_count;		/*Probe req denied count*/
+	u16 supression_age_out;	/*seconds*/
+	u16 dual_band_age_out;		/*seconds*/
+	int rssi_threshold;			/*Accept Client RSSI threshold*/
+	u16 scan_cycle_period_threshold;
+}t_band_select;
+
+enum{
+	BAND_SELECT_PROBE_RESPONSE = 0,
+	BAND_SELECT_PROBE_REFUSE
+};
+
+#endif
+
 /**
  * struct hostapd_bss_config - Per-BSS configuration
  */
@@ -553,6 +570,10 @@ struct hostapd_bss_config {
 	int radio_measurements;
 
 	int vendor_vht;
+
+#ifdef DUAL_BAND_SELECT
+	t_band_select band_select;
+#endif
 };
 
 
--- a/src/ap/beacon.c
+++ b/src/ap/beacon.c
@@ -559,6 +559,14 @@ void handle_probe_req(struct hostapd_dat
 		.frame_info = fi,
 	};
 
+#ifdef DUAL_BAND_SELECT
+	if(BAND_SELECT_PROBE_REFUSE == dual_band_select_check(hapd,mgmt,fi)){
+		wpa_printf(MSG_DEBUG,"Probe request form" MACSTR "is not responsed because of band select",
+			 MAC2STR(mgmt->sa));
+		return;
+	}
+#endif
+
 	ie = mgmt->u.probe_req.variable;
 	if (len < IEEE80211_HDRLEN + sizeof(mgmt->u.probe_req))
 		return;
--- a/src/ap/drv_callbacks.c
+++ b/src/ap/drv_callbacks.c
@@ -830,6 +830,7 @@ static int hostapd_mgmt_rx(struct hostap
 	os_memset(&fi, 0, sizeof(fi));
 	fi.datarate = rx_mgmt->datarate;
 	fi.ssi_signal = rx_mgmt->ssi_signal;
+	fi.freq = rx_mgmt->freq;
 
 	if (hapd == HAPD_BROADCAST) {
 		size_t i;
--- a/src/ap/hostapd.h
+++ b/src/ap/hostapd.h
@@ -28,6 +28,54 @@ union wps_event_data;
 struct mesh_conf;
 #endif /* CONFIG_MESH */
 
+#ifdef DUAL_BAND_SELECT
+struct band_select_sta_info {
+	//struct band_select_sta_info *next; /* next entry in sta list */
+	//struct band_select_sta_info *hnext; /* next entry in hash table list */
+	u8 addr[6];
+	u8 is_5g_sta;
+	u8 probe_cycle_count;
+	struct os_reltime access_time;
+	struct os_reltime last_probe;
+};
+
+#define MAX_BAND_SELECT_NUM 4
+#define BAND_SELECT_SHM_MAGIC_NUM 4660
+#define MAX_BAND_SELECT_STA_NUM	256
+enum {
+	BAND_SELECT_SSID_2G_INDEX = 0,
+	BAND_SELECT_SSID_5G_INDEX = 1
+};
+
+enum {
+	DUAL_BAND_SELECT_BSS_UNCONFIGED = 0,
+	DUAL_BAND_SELECT_BSS_NO = 1,
+	DUAL_BAND_SELECT_BSS_YES = 2
+};
+
+#if 0
+struct band_select_shm_sta{
+		struct band_select_sta_info *band_select_sta_list; /* Band select STA info list head */
+#define BAND_SELECT_STA_HASH_SIZE 512
+		struct band_select_sta_info *band_select_sta_hash[BAND_SELECT_STA_HASH_SIZE];
+};
+
+#endif
+
+struct band_select_share_memory{
+	unsigned int table_init_magic_num;
+	unsigned char dual_band_2g_ssid_num;
+	unsigned char dual_band_5g_ssid_num;
+	char dual_band_ssid[2][8][HOSTAPD_MAX_SSID_LEN];
+	unsigned char band_select_ssid_num;
+	unsigned char band_select_ssid[MAX_BAND_SELECT_NUM][HOSTAPD_MAX_SSID_LEN];
+	//struct band_select_shm_sta band_select_sta[MAX_BAND_SELECT_NUM];
+	struct band_select_sta_info band_select_sta[MAX_BAND_SELECT_NUM][MAX_BAND_SELECT_STA_NUM];
+};
+
+#endif
+
+
 struct hostapd_iface;
 
 struct hapd_interfaces {
@@ -75,6 +123,7 @@ struct hostapd_frame_info {
 	u32 channel;
 	u32 datarate;
 	int ssi_signal; /* dBm */
+	u32 freq;	/*Frequency (in MHz)*/
 };
 
 enum wps_status {
@@ -96,7 +145,6 @@ struct wps_stat {
 	u8 peer_addr[ETH_ALEN];
 };
 
-
 /**
  * struct hostapd_data - hostapd per-BSS data structure
  */
@@ -118,6 +166,11 @@ struct hostapd_data {
 #define STA_HASH(sta) (sta[5])
 	struct sta_info *sta_hash[STA_HASH_SIZE];
 
+#ifdef DUAL_BAND_SELECT
+	int is_dual_band_bss;
+	int band_select_2g_ssid_index;
+#endif
+
 	/*
 	 * Bitfield for indicating which AIDs are allocated. Only AID values
 	 * 1-2007 are used and as such, the bit at index 0 corresponds to AID
@@ -307,6 +360,10 @@ struct hostapd_iface {
 	size_t num_bss;
 	struct hostapd_data **bss;
 
+#ifdef DUAL_BAND_SELECT
+	struct band_select_share_memory *band_select_shm;
+#endif
+
 	unsigned int wait_channel_update:1;
 	unsigned int cac_started:1;
 
--- a/wpa_supplicant/Makefile
+++ b/wpa_supplicant/Makefile
@@ -861,7 +861,8 @@ OBJS += ../src/ap/ap_list.o
 OBJS += ../src/ap/ieee802_11.o
 OBJS += ../src/ap/hw_features.o
 OBJS += ../src/ap/dfs.o
-CFLAGS += -DNEED_AP_MLME
+OBJS += ../src/ap/band_select.o
+CFLAGS += -DNEED_AP_MLME -DDUAL_BAND_SELECT
 endif
 ifdef CONFIG_WPS
 CFLAGS += -DEAP_SERVER_WSC
--- /dev/null
+++ b/src/ap/band_select.c
@@ -0,0 +1,291 @@
+/*
+ * Band Select Function
+ * Added by sunzh@wifisong.com
+ * 2016.7.19
+ */
+
+#include "utils/includes.h"
+
+#include "utils/common.h"
+#include "utils/eloop.h"
+#include "common/ieee802_11_defs.h"
+#include "common/ieee802_11_common.h"
+#include "common/wpa_ctrl.h"
+#include "common/sae.h"
+#include "wps/wps.h"
+#include "hostapd.h"
+#include "beacon.h"
+#include "ieee802_11_auth.h"
+#include "sta_info.h"
+#include "ieee802_1x.h"
+#include "wpa_auth.h"
+#include "wmm.h"
+#include "ap_list.h"
+#include "accounting.h"
+#include "ap_config.h"
+#include "ap_mlme.h"
+#include "ap_drv_ops.h"
+#include "ieee802_11.h"
+
+#ifdef DUAL_BAND_SELECT
+enum {
+    BAND_SELECT_DISABLE=0,
+    BAND_SELECT_ENABLE
+};
+
+enum {
+    BAND_SELECT_TABLE_INIT=0,
+    BAND_SELECT_TABLE_RESET,
+    BAND_SELECT_TABLE_UPDATE
+};
+
+enum {
+    BAND_SELECT_AGE_IN=0,
+    BAND_SELECT_AGE_OUT
+};
+
+void dual_band_sta_table_update(struct band_select_sta_info *sta,u8 init);
+u8 is_age_out(struct band_select_sta_info *sta,u16 age_timeout);
+
+
+int band_select_get_sta(struct band_select_sta_info *shm_sta, const u8 *sta)
+{
+    int i = 0;
+
+    for(i = 0; i < MAX_BAND_SELECT_STA_NUM; i++) {
+        if (shm_sta[i].addr[0] == sta[0] && shm_sta[i].addr[1] == sta[1] && shm_sta[i].addr[2] == sta[2] &&
+                shm_sta[i].addr[3] == sta[3] && shm_sta[i].addr[4] == sta[4] && shm_sta[i].addr[5] == sta[5])
+            return i;
+    }
+    return -1;
+}
+
+int band_select_add_sta(struct band_select_sta_info *shm_sta, const u8 *sta,u16 age_out_time)
+{
+    int i = 0;
+
+    for(i = 0; i < MAX_BAND_SELECT_STA_NUM; i++) {
+        if (shm_sta[i].addr[0] == 0 && shm_sta[i].addr[1] == 0 && shm_sta[i].addr[2] == 0 &&
+                shm_sta[i].addr[3] == 0 && shm_sta[i].addr[4] == 0 && shm_sta[i].addr[5] == 0) {
+            os_memcpy(shm_sta[i].addr,sta,ETH_ALEN);
+            dual_band_sta_table_update(shm_sta+i,BAND_SELECT_TABLE_INIT);
+            return i;
+        } else {
+            /*Remove the age out sta*/
+            if(is_age_out(shm_sta + i,age_out_time)) {
+                os_memset(shm_sta+i,0,sizeof(struct band_select_sta_info));
+            }
+        }
+    }
+    return -1;
+}
+
+
+
+u8 is_scan_cycle_period(struct band_select_sta_info *sta,u16 scan_cycle_period)
+{
+    struct os_reltime now;
+
+    os_get_reltime(&now);
+
+    if(sta->last_probe.sec == 0) {
+        wpa_printf(MSG_DEBUG,MACSTR ": %s line %d,scan period start!\n",MAC2STR(sta->addr),__FUNCTION__,__LINE__);
+        os_memcpy(&sta->last_probe,&now,sizeof(struct os_reltime));
+        return 1;
+    }
+
+    if(((now.sec*1000 + now.usec/1000) - (sta->last_probe.sec*1000 + sta->last_probe.usec/1000)) > scan_cycle_period) {
+        wpa_printf(MSG_DEBUG,MACSTR ": %s line %d,scan period %d ms\n",MAC2STR(sta->addr),__FUNCTION__,__LINE__,((now.sec*1000 + now.usec/1000) - (sta->last_probe.sec*1000 + sta->last_probe.usec/1000)));
+        os_memcpy(&sta->last_probe,&now,sizeof(struct os_reltime));
+        return 1;
+    }
+
+    os_memcpy(&sta->last_probe,&now,sizeof(struct os_reltime));
+    return 0;
+
+}
+
+u8 is_age_out(struct band_select_sta_info *sta,u16 age_timeout)
+{
+    struct os_reltime now;
+
+    os_get_reltime(&now);
+
+    if((now.sec - sta->access_time.sec) > age_timeout) {
+        return BAND_SELECT_AGE_OUT;
+    }
+
+    return BAND_SELECT_AGE_IN;
+}
+
+void dual_band_sta_table_update(struct band_select_sta_info *sta,u8 init)
+{
+    if(init == BAND_SELECT_TABLE_UPDATE) {
+
+        sta->probe_cycle_count++;
+        return;
+    }
+
+    os_get_reltime(&(sta->access_time));
+
+    //sta->is_5g_sta = 0;
+
+    if(init == BAND_SELECT_TABLE_INIT) {
+        sta->probe_cycle_count = 0;
+        os_memset(&sta->last_probe,0,sizeof(struct os_reltime));
+    } else {
+        sta->probe_cycle_count = 1;
+        os_memcpy(&sta->last_probe,&sta->access_time,sizeof(struct os_reltime));
+    }
+
+    return;
+}
+
+int dual_band_sta_probe_access(struct band_select_sta_info *shm_sta,const u8 *addr,u16 age_out_time)
+{
+    int index = 0;
+
+    index = band_select_get_sta(shm_sta, addr);
+    if (index >= 0)
+        return index;
+
+    wpa_printf(MSG_DEBUG, "  New STA Probe");
+
+    return band_select_add_sta(shm_sta, addr,age_out_time);
+}
+
+
+/*
+ * *
+ * * return 1 to refuse the probe request message
+ * */
+u8 dual_band_select_check(struct hostapd_data *hapd,const struct ieee80211_mgmt *mgmt,struct hostapd_frame_info *fi)
+{
+    struct band_select_sta_info *sta = NULL;
+    struct hostapd_iface *interfaces = hapd->iface;
+    struct band_select_sta_info *band_select_sta = NULL;
+
+    int ret = 0;
+    int index = 0,i=0;
+    u8 is_5g_sta = 0;
+
+
+    if(hapd->conf->band_select.band_select_enable == BAND_SELECT_DISABLE)
+        return BAND_SELECT_PROBE_RESPONSE;
+
+    /*If it is not initialized response normally*/
+    if((interfaces->band_select_shm == NULL) ||
+            (interfaces->band_select_shm->table_init_magic_num != BAND_SELECT_SHM_MAGIC_NUM)) {
+        return BAND_SELECT_PROBE_RESPONSE;
+    }
+
+    /*Channel 36~165*/
+    is_5g_sta = ((fi->freq >= 5180)&&(fi->freq <= 5825))?1:0;
+
+    if((is_5g_sta) && (fi->ssi_signal < hapd->conf->band_select.rssi_threshold )) {
+        wpa_printf(MSG_DEBUG,MACSTR "%s line %d,rssi is too low(%d),refused\n",MAC2STR(mgmt->sa),__FUNCTION__,__LINE__,fi->ssi_signal);
+        return BAND_SELECT_PROBE_REFUSE;
+    }
+
+    switch(hapd->is_dual_band_bss) {
+    case DUAL_BAND_SELECT_BSS_NO:
+        break;
+    case DUAL_BAND_SELECT_BSS_YES:
+        for(i = 0; i < interfaces->band_select_shm->band_select_ssid_num; i++) {
+            if(os_strlen(interfaces->band_select_shm->band_select_ssid[i]) != hapd->conf->ssid.ssid_len)
+                continue;
+
+            if(os_memcmp(interfaces->band_select_shm->band_select_ssid[i],
+                         hapd->conf->ssid.ssid,hapd->conf->ssid.ssid_len) == 0) {
+                band_select_sta = interfaces->band_select_shm->band_select_sta[i];
+                wpa_printf(MSG_DEBUG,MACSTR "%s line %d,band select ssid=%s,\n",MAC2STR(mgmt->sa),__FUNCTION__,__LINE__,hapd->conf->ssid.ssid);
+                break;
+            }
+        }
+
+        break;
+    default:
+        for(i = 0; i < interfaces->band_select_shm->band_select_ssid_num; i++) {
+            if(os_strlen(interfaces->band_select_shm->band_select_ssid[i]) != hapd->conf->ssid.ssid_len) {
+                hapd->is_dual_band_bss = DUAL_BAND_SELECT_BSS_NO;
+                continue;
+            }
+
+            if(os_memcmp(interfaces->band_select_shm->band_select_ssid[i],
+                         hapd->conf->ssid.ssid,hapd->conf->ssid.ssid_len) == 0) {
+                band_select_sta = interfaces->band_select_shm->band_select_sta[i];
+                hapd->is_dual_band_bss = DUAL_BAND_SELECT_BSS_YES;
+                wpa_printf(MSG_DEBUG,MACSTR "%s line %d,band select ssid=%s,\n",MAC2STR(mgmt->sa),__FUNCTION__,__LINE__,hapd->conf->ssid.ssid);
+                break;
+            } else
+                hapd->is_dual_band_bss = DUAL_BAND_SELECT_BSS_NO;
+        }
+
+        break;
+    }
+
+    if(band_select_sta == NULL)
+        return BAND_SELECT_PROBE_RESPONSE;
+
+    if(hapd->is_dual_band_bss != DUAL_BAND_SELECT_BSS_YES) {
+        wpa_printf(MSG_DEBUG,MACSTR " %s line %d:SSID %s is non band select bss\n",MAC2STR(mgmt->sa),__FUNCTION__,__LINE__,
+               hapd->conf->ssid.ssid);
+        return BAND_SELECT_PROBE_RESPONSE;
+    }
+
+    index = dual_band_sta_probe_access(band_select_sta, mgmt->sa,hapd->conf->band_select.supression_age_out);
+    if(index < 0) {
+        /*If there are any errors happened, process the probe normally*/
+        wpa_printf(MSG_DEBUG,MACSTR "%s line %d\n",MAC2STR(mgmt->sa),__FUNCTION__,__LINE__);
+        return BAND_SELECT_PROBE_RESPONSE;
+    }
+
+    sta = band_select_sta + index;
+    wpa_printf(MSG_DEBUG,MACSTR "%s line %d,index=%d ,is_5g:%d\n",MAC2STR(sta->addr),__FUNCTION__,__LINE__,index,sta->is_5g_sta);
+
+    /*5G user is always response only when user number is too much*/
+    if(is_5g_sta) {
+        sta->is_5g_sta = is_5g_sta;
+        wpa_printf(MSG_DEBUG,MACSTR "%s line %d,5G (%d Hz) user, response!!!!\n",MAC2STR(mgmt->sa),__FUNCTION__,__LINE__,fi->freq);
+        return BAND_SELECT_PROBE_RESPONSE;
+    }
+
+    if(sta->is_5g_sta) {
+        wpa_printf(MSG_DEBUG,MACSTR "%s line %d,5G  user, scanning on %d Hz \n",MAC2STR(sta->addr),__FUNCTION__,__LINE__,fi->freq);
+        if(BAND_SELECT_AGE_OUT == is_age_out(sta,hapd->conf->band_select.dual_band_age_out)) {
+            dual_band_sta_table_update(sta,BAND_SELECT_TABLE_RESET);
+            wpa_printf(MSG_DEBUG,MACSTR "%s line %d,5G user which work on 2.4G age out,refused again\n",MAC2STR(sta->addr),__FUNCTION__,__LINE__);
+            return BAND_SELECT_PROBE_REFUSE;
+        }
+
+        if(BAND_SELECT_AGE_IN == is_age_out(sta,hapd->conf->band_select.supression_age_out)) {
+            wpa_printf(MSG_DEBUG,MACSTR "%s line %d,5G user which work on 2.4G in suppression aging time,refuse again\n",MAC2STR(sta->addr),__FUNCTION__,__LINE__);
+            return BAND_SELECT_PROBE_REFUSE;
+        } else {
+            wpa_printf(MSG_DEBUG,MACSTR "%s line %d,5G user which work on 2.4G,age out suppression time, response\n",MAC2STR(sta->addr),__FUNCTION__,__LINE__);
+            return BAND_SELECT_PROBE_RESPONSE;
+        }
+
+    } else {
+        if(BAND_SELECT_AGE_OUT == is_age_out(sta,hapd->conf->band_select.supression_age_out)) {
+            dual_band_sta_table_update(sta,BAND_SELECT_TABLE_RESET);
+            wpa_printf(MSG_DEBUG,MACSTR "%s line %d,2.4G user age out,response\n",MAC2STR(sta->addr),__FUNCTION__,__LINE__);
+            return BAND_SELECT_PROBE_RESPONSE;
+        }
+    }
+
+    if(is_scan_cycle_period(sta,hapd->conf->band_select.scan_cycle_period_threshold)) {
+        dual_band_sta_table_update(sta,BAND_SELECT_TABLE_UPDATE);
+        wpa_printf(MSG_DEBUG,MACSTR ": %s line %d, another probe,update count=%d\n",MAC2STR(sta->addr),__FUNCTION__,__LINE__,sta->probe_cycle_count);
+    }
+
+    if(sta->probe_cycle_count > hapd->conf->band_select.probe_cycle_count) {
+        wpa_printf(MSG_DEBUG,MACSTR "%s line %d, 2.4G user cycle count over(count=%d), response\n",MAC2STR(sta->addr),__FUNCTION__,__LINE__,sta->probe_cycle_count);
+        return BAND_SELECT_PROBE_RESPONSE;
+    } else {
+        wpa_printf(MSG_DEBUG,MACSTR "%s line %d,2.4G user cycle count in(count=%d), refuse\n",MAC2STR(sta->addr),__FUNCTION__,__LINE__,sta->probe_cycle_count);
+        return BAND_SELECT_PROBE_REFUSE;
+    }
+}
+
+#endif
--- a/hostapd/main.c
+++ b/hostapd/main.c
@@ -28,7 +28,9 @@
 #include "config_file.h"
 #include "eap_register.h"
 #include "ctrl_iface.h"
-
+#ifdef DUAL_BAND_SELECT
+#include <sys/shm.h>
+#endif
 
 struct hapd_global {
 	void **drv_priv;
@@ -545,8 +547,9 @@ static int gen_uuid(const char *txt_addr
 int main(int argc, char *argv[])
 {
 	struct hapd_interfaces interfaces;
+	struct hostapd_iface *iface;
 	int ret = 1;
-	size_t i, j;
+	size_t i, j,z;
 	int c, debug = 0;
 	const char *log_file = NULL;
 	const char *entropy_file = NULL;
@@ -556,6 +559,11 @@ int main(int argc, char *argv[])
 	int enable_trace_dbg = 0;
 #endif /* CONFIG_DEBUG_LINUX_TRACING */
 
+#ifdef DUAL_BAND_SELECT
+	void *shm = NULL;//
+	int shmid;//
+#endif
+
 	if (os_program_init())
 		return -1;
 
@@ -740,6 +748,78 @@ int main(int argc, char *argv[])
 
 	hostapd_global_ctrl_iface_init(&interfaces);
 
+#ifdef DUAL_BAND_SELECT
+
+    //for (i = 0; i < interfaces.count; i++)
+    iface=interfaces.iface[0];
+    {
+        /*Creat share memory for IPC between two band chip*/
+        //Creat share memory
+        shmid = shmget((key_t)1316, sizeof(struct band_select_share_memory), 0666|IPC_CREAT);
+        if(shmid == -1) {
+            wpa_printf(MSG_ERROR, "shmget failed");
+            goto out;
+        }
+        //share memory attached to interface
+        iface->band_select_shm = shmat(shmid, 0, 0);
+        if(shm == (void*)-1) {
+            wpa_printf(MSG_ERROR, "shmget failed");
+            goto out;
+        }
+        os_memset(iface->band_select_shm->band_select_sta,0,MAX_BAND_SELECT_NUM*MAX_BAND_SELECT_STA_NUM*sizeof(struct band_select_sta_info));
+
+
+        if((iface->freq >= 5180)&&(iface->freq <= 5825))
+            iface->band_select_shm->dual_band_5g_ssid_num = iface->num_bss;
+        else
+            iface->band_select_shm->dual_band_2g_ssid_num = iface->num_bss;
+
+        for(j = 0; j < iface->num_bss; j++) {
+
+            if((iface->freq >= 5180)&&(iface->freq <= 5825)) {
+                os_memcpy(iface->band_select_shm->dual_band_ssid[BAND_SELECT_SSID_5G_INDEX][j],
+                          iface->bss[j]->conf->ssid.ssid,
+                          iface->bss[j]->conf->ssid.ssid_len);
+            } else {
+
+                os_memcpy(iface->band_select_shm->dual_band_ssid[BAND_SELECT_SSID_2G_INDEX][j],
+                          iface->bss[j]->conf->ssid.ssid,
+                          iface->bss[j]->conf->ssid.ssid_len);
+            }
+        }
+    }
+
+    if(iface->band_select_shm->table_init_magic_num == BAND_SELECT_SHM_MAGIC_NUM) {
+        iface->band_select_shm->band_select_ssid_num = 0;
+
+        for(i = 0,z = 0; i < iface->band_select_shm->dual_band_2g_ssid_num; i++) {
+
+            if(os_strlen(iface->band_select_shm->dual_band_ssid[BAND_SELECT_SSID_2G_INDEX][i]) == 0)
+                continue;
+            for(j = 0; j < iface->band_select_shm->dual_band_5g_ssid_num; j++) {
+                if(os_strlen(iface->band_select_shm->dual_band_ssid[BAND_SELECT_SSID_5G_INDEX][j]) == 0)
+                    continue;
+
+                if(os_strlen(iface->band_select_shm->dual_band_ssid[BAND_SELECT_SSID_5G_INDEX][j]) !=
+                        os_strlen(iface->band_select_shm->dual_band_ssid[BAND_SELECT_SSID_2G_INDEX][i]))
+                    continue;
+
+                if(os_memcmp(iface->band_select_shm->dual_band_ssid[BAND_SELECT_SSID_2G_INDEX][i],
+                             iface->band_select_shm->dual_band_ssid[BAND_SELECT_SSID_5G_INDEX][j],
+                             os_strlen(iface->band_select_shm->dual_band_ssid[BAND_SELECT_SSID_2G_INDEX][i])) == 0) {
+                    iface->band_select_shm->band_select_ssid_num++;
+
+                    os_memcpy(iface->band_select_shm->band_select_ssid[z++],
+                              iface->band_select_shm->dual_band_ssid[BAND_SELECT_SSID_2G_INDEX][i],
+                              os_strlen(iface->band_select_shm->dual_band_ssid[BAND_SELECT_SSID_2G_INDEX][i]));
+                }
+            }
+        }
+    } else {
+        iface->band_select_shm->table_init_magic_num = BAND_SELECT_SHM_MAGIC_NUM;
+    }
+#endif
+
 	if (hostapd_global_run(&interfaces, daemonize, pid_file)) {
 		wpa_printf(MSG_ERROR, "Failed to start eloop");
 		goto out;
@@ -748,6 +828,17 @@ int main(int argc, char *argv[])
 	ret = 0;
 
  out:
+#ifdef DUAL_BAND_SELECT
+	//Dettach share memory
+    if(shmdt(iface->band_select_shm) == -1) {
+		wpa_printf(MSG_ERROR, "shmdt failed");
+	}
+	//Delete share memory
+    if(shmctl(shmid, IPC_RMID, 0) == -1) {
+		wpa_printf(MSG_ERROR, "shmctl(IPC_RMID) failed");
+	}
+#endif
+
 	hostapd_global_ctrl_iface_deinit(&interfaces);
 	/* Deinitialize all interfaces */
 	for (i = 0; i < interfaces.count; i++) {
--- a/hostapd/config_file.c
+++ b/hostapd/config_file.c
@@ -3301,6 +3301,20 @@ static int hostapd_config_fill(struct ho
 	} else if (os_strcmp(buf, "wowlan_triggers") == 0) {
 		os_free(bss->wowlan_triggers);
 		bss->wowlan_triggers = os_strdup(pos);
+#ifdef DUAL_BAND_SELECT
+	} else if (os_strcmp(buf, "band_select_enable") == 0) {
+		bss->band_select.band_select_enable = atoi(pos);
+	} else if (os_strcmp(buf, "rssi_threshold") == 0) {
+		bss->band_select.rssi_threshold = atoi(pos);
+	} else if (os_strcmp(buf, "probe_cycle_count") == 0) {
+		bss->band_select.probe_cycle_count = atoi(pos);
+	} else if (os_strcmp(buf, "dual_band_age_out") == 0) {
+		bss->band_select.dual_band_age_out = atoi(pos);
+	} else if (os_strcmp(buf, "supression_age_out") == 0) {
+		bss->band_select.supression_age_out = atoi(pos);
+	} else if (os_strcmp(buf, "scan_cycle_period_threshold") == 0) {
+		bss->band_select.scan_cycle_period_threshold = atoi(pos);
+#endif
 	} else {
 		wpa_printf(MSG_ERROR,
 			   "Line %d: unknown configuration item '%s'",
