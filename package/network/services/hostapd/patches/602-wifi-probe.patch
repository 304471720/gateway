--- a/hostapd/Makefile
+++ b/hostapd/Makefile
@@ -846,6 +846,11 @@ ifdef CONFIG_IEEE80211N
 OBJS += ../src/ap/ieee802_11_ht.o
 endif
 
+ifndef WIFI_PROBE_BOARD
+OBJS += ../src/ap/wifi_probe.o
+OBJS += ../src/ap/sha1.o
+endif
+
 ifdef CONFIG_IEEE80211AC
 OBJS += ../src/ap/ieee802_11_vht.o
 endif
--- a/hostapd/config_file.c
+++ b/hostapd/config_file.c
@@ -29,6 +29,10 @@ hostapd_parse_radius_attr(const char *va
 #endif /* EAP_SERVER */
 #endif /* CONFIG_NO_RADIUS */
 
+extern char *g_report_server;
+extern char *g_report_port;
+extern u32 g_report_interval;
+extern u8 g_wifi_probe_disable;
 
 #ifndef CONFIG_NO_VLAN
 static int hostapd_config_read_vlan_file(struct hostapd_bss_config *bss,
@@ -3315,6 +3319,17 @@ static int hostapd_config_fill(struct ho
 	} else if (os_strcmp(buf, "scan_cycle_period_threshold") == 0) {
 		bss->band_select.scan_cycle_period_threshold = atoi(pos);
 #endif
+
+#ifdef WIFI_PROBE
+	} else if (os_strcmp(buf, "probe_server") == 0) {
+		g_report_server = os_strdup(pos);
+	} else if (os_strcmp(buf, "probe_port") == 0) {
+		g_report_port = os_strdup(pos);
+	} else if (os_strcmp(buf, "probe_interval") == 0) {
+		g_report_interval = atoi(pos);
+	} else if (os_strcmp(buf, "wifi_probe_disable") == 0) {
+		g_wifi_probe_disable = atoi(pos);
+#endif
 	} else {
 		wpa_printf(MSG_ERROR,
 			   "Line %d: unknown configuration item '%s'",
--- a/hostapd/main.c
+++ b/hostapd/main.c
@@ -820,6 +820,10 @@ int main(int argc, char *argv[])
     }
 #endif
 
+#ifdef WIFI_PROBE
+	init_wifi_probe();
+#endif
+
 	if (hostapd_global_run(&interfaces, daemonize, pid_file)) {
 		wpa_printf(MSG_ERROR, "Failed to start eloop");
 		goto out;
--- a/src/ap/ieee802_11.c
+++ b/src/ap/ieee802_11.c
@@ -2262,9 +2262,17 @@ int ieee802_11_mgmt(struct hostapd_data
 
 
 	if (stype == WLAN_FC_STYPE_PROBE_REQ) {
+		#ifdef WIFI_PROBE
+		handle_wifi_probe(mgmt, fi);
+		#else
 		handle_probe_req(hapd, mgmt, len, fi);
+		#endif
 		return 1;
 	}
+	/*If it is set to wifi probe, then disable the AP function.*/
+	#ifdef WIFI_PROBE
+	return 0;
+	#endif
 
 	if (os_memcmp(mgmt->da, hapd->own_addr, ETH_ALEN) != 0) {
 		hostapd_logger(hapd, mgmt->sa, HOSTAPD_MODULE_IEEE80211,
--- /dev/null
+++ b/src/ap/wifi_probe.c
@@ -0,0 +1,423 @@
+/*
+ * Band Select Function
+ * Added by sunzh@wifisong.com
+ * 2017.4.25
+ */
+
+#include <stdio.h>
+#include <errno.h>
+#include <ctype.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <getopt.h>
+#include <sys/param.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <signal.h>
+#include <sys/types.h>
+#include <endian.h>
+#include <sys/time.h>
+#include <sys/ioctl.h>
+#include <net/if.h>
+
+#include "utils/includes.h"
+
+#include "utils/common.h"
+#include "utils/eloop.h"
+#include "hostapd.h"
+#include "common/ieee802_11_defs.h"
+
+#include "sha1.h"
+#include <netdb.h>
+
+
+#ifdef DUAL_BAND_SELECT
+
+#define CONFIG_FILE "/etc/init_config"
+
+u8 router_secret[100] = { 0 };
+u64 router_id = 0;
+
+int client_fd = 0;
+char *g_report_server = "up2.lbsdata.org";
+char *g_report_port = "2501";
+u32 g_report_interval = 0;
+u8 g_wifi_probe_disable = 0;
+
+struct ble_dev_info
+{
+	u8 mac[6];
+	s8 rssi;
+};
+
+typedef struct __reportal_header__ {
+	u8 dev_type;// 1:WiFi , 2:BLE
+	u16 ble_dev_cnt;
+} __attribute__((packed)) reportal_header;
+
+#define COMPOUND_MESSAGE 1
+#define STATION_MESSAGE  1
+
+#define RTLS_MESSAGE_TYPE_BLE_REPORT 3
+#define RTLS_MESSAGE_TYPE_PROBE_REPORT 4
+
+#define MESSAGE_TYPE_RTLS 1
+#define DEVICE_VENDOR_WIFISONG 1
+#define DEVICE_VENDOR_ARUBA 2
+#define DEVICE_VENDOR_H3C 3
+#define DEVICE_VENDOR_AEROHIVE 4
+
+typedef struct _wifisong_header
+{
+	u16 length; //length of payload
+	u8  message_type;
+	u8  version_major;
+	u8  version_minor;
+	u8  version_build;
+	u64 device_id; //
+	u8  device_mac[6];
+	u16 device_vendor;
+}__attribute__((packed)) wifisong_header_t;
+
+
+
+typedef struct _rtls_header
+{
+	u16  length; //length of rtls payload
+	u8   rtls_type; //rtls message type
+	u8   version_major;
+	u8   version_minor;
+	u8   version_build;
+	u64  ap_id;
+	u8   ap_mac[6];
+	u16  ap_vendor;
+}__attribute__((packed)) rtls_header_t;
+
+
+typedef struct _compound_message
+{
+	rtls_header_t rtls_header;
+	u16 number;
+}__attribute__((packed)) compound_message_t;
+
+#define BLE_MSG_HEADER_LEN (sizeof(wifisong_header_t) + sizeof(rtls_header_t) + sizeof(reportal_header))
+
+#define DIGEST_LEN 20
+#define TIMESTAMP_SIZE 4
+#define BLE_REPORT_HEADER_LEN (sizeof(reportal_header))
+#define BLE_REPORT_PAYLOAD_LEN 1400
+#define TRANSFER_MAX_BUF_SIZE 16 * 1024
+#define BLE_REPORT_CNT_PER_PKT (BLE_REPORT_PAYLOAD_LEN/sizeof(struct ble_dev_info))
+#define MAX_BLE_PKT_PAYLOAD_LEN (BLE_MSG_HEADER_LEN + BLE_REPORT_CNT_PER_PKT*sizeof(struct ble_dev_info))
+
+#define DEVICE_TYPE_WIFI 1
+#define DEVICE_TYPE_BLE 2
+
+u16 device_counter = 0;
+struct addrinfo *res,*rp,hints;
+u8 transfer_buf[TRANSFER_MAX_BUF_SIZE];
+wifisong_header_t *wifisong_header = (wifisong_header_t *)transfer_buf;
+wifisong_header_t wifisong_header_tmp;
+rtls_header_t rtls_header_tmp;
+rtls_header_t *rtls_header = (rtls_header_t *)(transfer_buf + sizeof(wifisong_header_t));
+
+
+int get_conf_value(char *file_path, char *key_name, char *value)
+{
+	FILE *fp = NULL;
+	char *line = NULL, *substr = NULL;
+	size_t len = 0, tlen = 0;
+	ssize_t read = 0;
+    char buf[4096] = { 0 };
+	if(file_path == NULL || key_name == NULL || value == NULL) {
+		printf("paramer is invaild!\n");
+		return -1;
+	}
+	fp = fopen(file_path, "r");
+	if (fp == NULL) {
+		printf("open config file is error!\n");
+		return -1;
+	}
+	while ((read = getline(&line, &len, fp)) != -1) {
+		substr = strstr(line, key_name);
+		if(substr == NULL) {
+			continue;
+		} else {
+			tlen = strlen(key_name);
+			if(line[tlen] == '=') {
+				strncpy(buf, &line[tlen+1], len-tlen+1);
+				tlen = strlen(buf);
+				//replace enter key
+				*(buf+tlen-1) = '\0';
+                strcpy(value,buf);
+				break;
+			} else {
+				printf("config file format is invaild tlen is %d len is %d\n", (int)tlen, (int)len);
+				fclose(fp);
+				return -2;
+			}
+		}
+	}
+	if(substr == NULL) {
+		printf("key: %s is not in config file!\n", key_name);
+		fclose(fp);
+		return -1;
+	}
+	free(line);
+	fclose(fp);
+	return 0;
+}
+u64 get_routerid(void)
+{
+	u8 buf[32];
+
+	if(get_conf_value(CONFIG_FILE,"router_id",buf) == 0)
+		return router_id = atoll(buf);
+	else
+		return 0;
+}
+
+int get_secret(u8 *secret)
+{
+	memset(secret,0,100);
+
+	if(get_conf_value(CONFIG_FILE,"share_secret",secret) == 0)
+		return 0;
+	else
+		return 1;
+}
+
+int get_router_mac(u8 *mac)
+{
+	char tmpbuf[32] = {0};
+	char ifname[16] = {0};
+	static char shellCmd[64] = {0};
+
+	struct ifreq ifreq;
+	int sock;
+
+	if(mac == NULL)
+		return -1;
+
+	memset(shellCmd,0,sizeof(shellCmd));
+	sprintf(shellCmd,"%s","uci get network.wan.ifname | tr -d \'\n\'");
+	FILE *fcmd = popen(shellCmd, "r");
+	fgets(ifname, sizeof(ifname), fcmd);
+	pclose(fcmd);
+
+	if((sock=socket(AF_INET,SOCK_STREAM,0)) <0)
+    {
+		perror( "socket ");
+		return -1;
+	}
+
+	memset(&ifreq,0,sizeof(struct ifreq));
+    strcpy(ifreq.ifr_name,ifname);
+    if(ioctl(sock,SIOCGIFHWADDR,&ifreq) <0)
+    {
+        perror( "ioctl get mac address");
+        return -1;
+    }
+
+	memcpy(mac,(unsigned char *)ifreq.ifr_hwaddr.sa_data,6);
+
+	return 0;
+}
+
+
+
+void udp_init(void)
+{
+	memset(&hints,0,sizeof(struct addrinfo));
+	hints.ai_family = AF_INET;
+	hints.ai_socktype = SOCK_DGRAM;
+	hints.ai_protocol = 0;
+
+	if(0 != getaddrinfo(g_report_server,g_report_port,&hints,&res))
+	{
+		wpa_printf(MSG_DEBUG,"getaddrinfo() error: %s\n",strerror(errno));
+	}
+
+	for(rp=res;rp != NULL;rp= res->ai_next)
+	{
+		client_fd = socket(rp->ai_family,rp->ai_socktype,rp->ai_protocol);
+		if(client_fd == -1)
+			continue;
+		break;
+	}
+
+}
+
+u8 init_wifi_probe()
+{
+	get_routerid();
+	get_secret(router_secret);
+	get_router_mac(wifisong_header->device_mac);
+	memcpy(rtls_header->ap_mac,wifisong_header->device_mac,6);
+
+	wifisong_header->length = sizeof(rtls_header_t);
+	wifisong_header->version_major = 0;
+	wifisong_header->version_minor = 0;
+	wifisong_header->version_build = 1;
+	wifisong_header->message_type = MESSAGE_TYPE_RTLS;
+	wifisong_header->device_vendor = htobe16(DEVICE_VENDOR_WIFISONG);
+	wifisong_header->device_id = htobe64(router_id);
+
+	rtls_header->length = 0;
+	rtls_header->ap_id = htobe64(router_id);
+	rtls_header->ap_vendor = htobe16(DEVICE_VENDOR_WIFISONG);
+	rtls_header->version_major = 0;
+	rtls_header->version_minor = 0;
+	rtls_header->version_build = 1;
+	rtls_header->rtls_type = RTLS_MESSAGE_TYPE_PROBE_REPORT;
+
+	udp_init();
+}
+
+
+void report_data(void)
+{
+	u16 msg_len = 0;
+	u16 total_msg_len = 0;
+	u8 ble_pkt_num = 0;
+	u16 ble_pkt_dev_cnt = 0;
+	u8 i = 0;
+	u8 *temp = NULL;
+
+	/*Padding the message header*/
+	ble_pkt_num = device_counter/BLE_REPORT_CNT_PER_PKT + 1;
+
+	for(i = 0; i < ble_pkt_num; i++)
+	{
+		ble_pkt_dev_cnt = device_counter - i*BLE_REPORT_CNT_PER_PKT;
+		if(ble_pkt_dev_cnt > BLE_REPORT_CNT_PER_PKT)
+		{
+			msg_len = MAX_BLE_PKT_PAYLOAD_LEN;
+		}
+		else
+			msg_len = BLE_MSG_HEADER_LEN + ble_pkt_dev_cnt*sizeof(struct ble_dev_info);
+
+		memcpy(transfer_buf + i*MAX_BLE_PKT_PAYLOAD_LEN + sizeof(wifisong_header_t),rtls_header,sizeof(rtls_header_t));
+		total_msg_len = htobe16(msg_len - sizeof(wifisong_header_t) - sizeof(rtls_header_t));
+		memcpy(transfer_buf + i*MAX_BLE_PKT_PAYLOAD_LEN + sizeof(wifisong_header_t),(u8 *)&total_msg_len,sizeof(u16));
+
+		total_msg_len = htobe16(msg_len - sizeof(rtls_header_t));
+		memcpy(transfer_buf + i*MAX_BLE_PKT_PAYLOAD_LEN,wifisong_header,sizeof(wifisong_header_t));
+		memcpy(transfer_buf + i*MAX_BLE_PKT_PAYLOAD_LEN,(u8 *)&total_msg_len,sizeof(u16));
+
+		temp = (u8 *)(transfer_buf + i*MAX_BLE_PKT_PAYLOAD_LEN);
+		sha1_hmac(router_secret,strlen(router_secret),transfer_buf + i*MAX_BLE_PKT_PAYLOAD_LEN,msg_len,temp + msg_len);
+
+		size_t sended_size = sendto(client_fd,transfer_buf + i*MAX_BLE_PKT_PAYLOAD_LEN,
+			msg_len + DIGEST_LEN,0,rp->ai_addr,sizeof(struct sockaddr));
+
+		if(sended_size != (msg_len + DIGEST_LEN))
+		{
+			wpa_printf(MSG_DEBUG,"sendto faild: %s\n",strerror(errno));
+		}
+
+	}
+	device_counter = 0;
+
+	return;
+}
+
+
+u8 handle_wifi_probe(const struct ieee80211_mgmt *mgmt,
+		      struct hostapd_frame_info *fi)
+{
+	u32 total_report_len = 0;
+	reportal_header message_hdr;
+	struct ble_dev_info dev_info;
+	u8 *pkt_data = NULL;
+	u8 ble_pkt_num = 0;
+	u16 ble_pkt_dev_cnt = 0;
+	static time_t scan_time;
+	u16 i = 0;
+	u8 *temp_buf = NULL;
+	int msg_len = 0;
+	int total_msg_len = 0;
+	int diff_time = 0;
+
+	if(g_wifi_probe_disable == 1)
+		return 0;
+
+	if(device_counter == 0)
+	{
+		scan_time = time(NULL);
+	}
+
+	/*If report_interval is set to 0, then report to server immediately */
+	if(g_report_interval == 0)
+	{
+		dev_info.rssi = fi->ssi_signal;
+		os_memcpy(dev_info.mac,mgmt->sa,6);
+
+		/*Padding the ble info*/
+		memcpy(transfer_buf + BLE_MSG_HEADER_LEN,(u8 *)&dev_info,sizeof(struct ble_dev_info));
+
+		/*Padding the RTLS message header*/
+		msg_len = sizeof(reportal_header) + sizeof(struct ble_dev_info);
+		rtls_header->length = htobe16(msg_len);
+
+		/*Padding the Standard message header*/
+		msg_len += sizeof(rtls_header_t);
+		wifisong_header->length = htobe16(msg_len);
+
+		message_hdr.dev_type = DEVICE_TYPE_WIFI;
+		message_hdr.ble_dev_cnt = htobe16(1);
+		memcpy(transfer_buf + sizeof(wifisong_header_t) + sizeof(rtls_header_t),
+			(u8 *)&message_hdr,sizeof(reportal_header));
+
+		total_msg_len = BLE_MSG_HEADER_LEN + sizeof(struct ble_dev_info);
+
+		temp_buf = (u8 *)transfer_buf;
+		sha1_hmac(router_secret,strlen(router_secret),transfer_buf,msg_len,temp_buf + total_msg_len);
+
+		size_t sended_size = sendto(client_fd,transfer_buf,total_msg_len + DIGEST_LEN,0,rp->ai_addr,sizeof(struct sockaddr));
+		if(sended_size != (total_msg_len + DIGEST_LEN)) {
+			wpa_printf(MSG_ERROR,"sendto error,sended_size is %d\n",sended_size);
+		}
+
+	}
+	else
+	{
+		dev_info.rssi = fi->ssi_signal;
+		os_memcpy(dev_info.mac,mgmt->sa,6);
+
+		ble_pkt_num = device_counter/BLE_REPORT_CNT_PER_PKT;
+		ble_pkt_dev_cnt = device_counter%BLE_REPORT_CNT_PER_PKT;
+
+		pkt_data = transfer_buf + BLE_MSG_HEADER_LEN + ble_pkt_num*MAX_BLE_PKT_PAYLOAD_LEN;
+
+		/*Pkt buffer cannot exceed buf array size*/
+		if(pkt_data + BLE_MSG_HEADER_LEN + ble_pkt_dev_cnt*sizeof(struct ble_dev_info)
+			- transfer_buf < TRANSFER_MAX_BUF_SIZE)
+		{
+			/*Padding the ble info*/
+			memcpy(pkt_data + ble_pkt_dev_cnt*sizeof(struct ble_dev_info),
+				(u8 *)&dev_info,sizeof(struct ble_dev_info));
+			device_counter++;
+
+			message_hdr.dev_type = DEVICE_TYPE_WIFI;
+			message_hdr.ble_dev_cnt = htobe16(ble_pkt_dev_cnt+1);
+			memcpy(pkt_data - sizeof(reportal_header),
+				(u8 *)&message_hdr,sizeof(reportal_header));
+
+		}
+		diff_time = difftime(time(NULL),scan_time);
+
+		/*Send the data if it reach the period time*/
+		if(diff_time >= g_report_interval)
+		{
+			report_data();
+		}
+	}
+
+	return 0;
+
+}
+#endif
+
--- /dev/null
+++ b/src/ap/sha1.c
@@ -0,0 +1,445 @@
+/*
+ *  FIPS-180-1 compliant SHA-1 implementation
+ *
+ *  Copyright (C) 2003-2006  Christophe Devine
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License, version 2.1 as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ *  MA  02110-1301  USA
+ */
+/*
+ *  The SHA-1 standard was published by NIST in 1993.
+ *
+ *  http://www.itl.nist.gov/fipspubs/fip180-1.htm
+ */
+
+#ifndef _CRT_SECURE_NO_DEPRECATE
+#define _CRT_SECURE_NO_DEPRECATE 1
+#endif
+
+#include <string.h>
+#include <stdio.h>
+
+#include "sha1.h"
+
+/*
+ * 32-bit integer manipulation macros (big endian)
+ */
+#ifndef GET_UINT32_BE
+#define GET_UINT32_BE(n,b,i)                    \
+{                                               \
+    (n) = ( (ulong) (b)[(i)    ] << 24 )        \
+        | ( (ulong) (b)[(i) + 1] << 16 )        \
+        | ( (ulong) (b)[(i) + 2] <<  8 )        \
+        | ( (ulong) (b)[(i) + 3]       );       \
+}
+#endif
+#ifndef PUT_UINT32_BE
+#define PUT_UINT32_BE(n,b,i)                    \
+{                                               \
+    (b)[(i)    ] = (uchar) ( (n) >> 24 );       \
+    (b)[(i) + 1] = (uchar) ( (n) >> 16 );       \
+    (b)[(i) + 2] = (uchar) ( (n) >>  8 );       \
+    (b)[(i) + 3] = (uchar) ( (n)       );       \
+}
+#endif
+
+/*
+ * Core SHA-1 functions
+ */
+void sha1_starts( sha1_context *ctx )
+{
+    ctx->total[0] = 0;
+    ctx->total[1] = 0;
+
+    ctx->state[0] = 0x67452301;
+    ctx->state[1] = 0xEFCDAB89;
+    ctx->state[2] = 0x98BADCFE;
+    ctx->state[3] = 0x10325476;
+    ctx->state[4] = 0xC3D2E1F0;
+}
+
+void sha1_process( sha1_context *ctx, uchar data[64] )
+{
+    ulong temp, W[16], A, B, C, D, E;
+
+    GET_UINT32_BE( W[0],  data,  0 );
+    GET_UINT32_BE( W[1],  data,  4 );
+    GET_UINT32_BE( W[2],  data,  8 );
+    GET_UINT32_BE( W[3],  data, 12 );
+    GET_UINT32_BE( W[4],  data, 16 );
+    GET_UINT32_BE( W[5],  data, 20 );
+    GET_UINT32_BE( W[6],  data, 24 );
+    GET_UINT32_BE( W[7],  data, 28 );
+    GET_UINT32_BE( W[8],  data, 32 );
+    GET_UINT32_BE( W[9],  data, 36 );
+    GET_UINT32_BE( W[10], data, 40 );
+    GET_UINT32_BE( W[11], data, 44 );
+    GET_UINT32_BE( W[12], data, 48 );
+    GET_UINT32_BE( W[13], data, 52 );
+    GET_UINT32_BE( W[14], data, 56 );
+    GET_UINT32_BE( W[15], data, 60 );
+
+#define S(x,n) ((x << n) | ((x & 0xFFFFFFFF) >> (32 - n)))
+
+#define R(t)                                            \
+(                                                       \
+    temp = W[(t -  3) & 0x0F] ^ W[(t - 8) & 0x0F] ^     \
+           W[(t - 14) & 0x0F] ^ W[ t      & 0x0F],      \
+    ( W[t & 0x0F] = S(temp,1) )                         \
+)
+
+#define P(a,b,c,d,e,x)                                  \
+{                                                       \
+    e += S(a,5) + F(b,c,d) + K + x; b = S(b,30);        \
+}
+
+    A = ctx->state[0];
+    B = ctx->state[1];
+    C = ctx->state[2];
+    D = ctx->state[3];
+    E = ctx->state[4];
+
+#define F(x,y,z) (z ^ (x & (y ^ z)))
+#define K 0x5A827999
+
+    P( A, B, C, D, E, W[0]  );
+    P( E, A, B, C, D, W[1]  );
+    P( D, E, A, B, C, W[2]  );
+    P( C, D, E, A, B, W[3]  );
+    P( B, C, D, E, A, W[4]  );
+    P( A, B, C, D, E, W[5]  );
+    P( E, A, B, C, D, W[6]  );
+    P( D, E, A, B, C, W[7]  );
+    P( C, D, E, A, B, W[8]  );
+    P( B, C, D, E, A, W[9]  );
+    P( A, B, C, D, E, W[10] );
+    P( E, A, B, C, D, W[11] );
+    P( D, E, A, B, C, W[12] );
+    P( C, D, E, A, B, W[13] );
+    P( B, C, D, E, A, W[14] );
+    P( A, B, C, D, E, W[15] );
+    P( E, A, B, C, D, R(16) );
+    P( D, E, A, B, C, R(17) );
+    P( C, D, E, A, B, R(18) );
+    P( B, C, D, E, A, R(19) );
+
+#undef K
+#undef F
+
+#define F(x,y,z) (x ^ y ^ z)
+#define K 0x6ED9EBA1
+
+    P( A, B, C, D, E, R(20) );
+    P( E, A, B, C, D, R(21) );
+    P( D, E, A, B, C, R(22) );
+    P( C, D, E, A, B, R(23) );
+    P( B, C, D, E, A, R(24) );
+    P( A, B, C, D, E, R(25) );
+    P( E, A, B, C, D, R(26) );
+    P( D, E, A, B, C, R(27) );
+    P( C, D, E, A, B, R(28) );
+    P( B, C, D, E, A, R(29) );
+    P( A, B, C, D, E, R(30) );
+    P( E, A, B, C, D, R(31) );
+    P( D, E, A, B, C, R(32) );
+    P( C, D, E, A, B, R(33) );
+    P( B, C, D, E, A, R(34) );
+    P( A, B, C, D, E, R(35) );
+    P( E, A, B, C, D, R(36) );
+    P( D, E, A, B, C, R(37) );
+    P( C, D, E, A, B, R(38) );
+    P( B, C, D, E, A, R(39) );
+
+#undef K
+#undef F
+
+#define F(x,y,z) ((x & y) | (z & (x | y)))
+#define K 0x8F1BBCDC
+
+    P( A, B, C, D, E, R(40) );
+    P( E, A, B, C, D, R(41) );
+    P( D, E, A, B, C, R(42) );
+    P( C, D, E, A, B, R(43) );
+    P( B, C, D, E, A, R(44) );
+    P( A, B, C, D, E, R(45) );
+    P( E, A, B, C, D, R(46) );
+    P( D, E, A, B, C, R(47) );
+    P( C, D, E, A, B, R(48) );
+    P( B, C, D, E, A, R(49) );
+    P( A, B, C, D, E, R(50) );
+    P( E, A, B, C, D, R(51) );
+    P( D, E, A, B, C, R(52) );
+    P( C, D, E, A, B, R(53) );
+    P( B, C, D, E, A, R(54) );
+    P( A, B, C, D, E, R(55) );
+    P( E, A, B, C, D, R(56) );
+    P( D, E, A, B, C, R(57) );
+    P( C, D, E, A, B, R(58) );
+    P( B, C, D, E, A, R(59) );
+
+#undef K
+#undef F
+
+#define F(x,y,z) (x ^ y ^ z)
+#define K 0xCA62C1D6
+
+    P( A, B, C, D, E, R(60) );
+    P( E, A, B, C, D, R(61) );
+    P( D, E, A, B, C, R(62) );
+    P( C, D, E, A, B, R(63) );
+    P( B, C, D, E, A, R(64) );
+    P( A, B, C, D, E, R(65) );
+    P( E, A, B, C, D, R(66) );
+    P( D, E, A, B, C, R(67) );
+    P( C, D, E, A, B, R(68) );
+    P( B, C, D, E, A, R(69) );
+    P( A, B, C, D, E, R(70) );
+    P( E, A, B, C, D, R(71) );
+    P( D, E, A, B, C, R(72) );
+    P( C, D, E, A, B, R(73) );
+    P( B, C, D, E, A, R(74) );
+    P( A, B, C, D, E, R(75) );
+    P( E, A, B, C, D, R(76) );
+    P( D, E, A, B, C, R(77) );
+    P( C, D, E, A, B, R(78) );
+    P( B, C, D, E, A, R(79) );
+
+#undef K
+#undef F
+
+    ctx->state[0] += A;
+    ctx->state[1] += B;
+    ctx->state[2] += C;
+    ctx->state[3] += D;
+    ctx->state[4] += E;
+}
+
+void sha1_update( sha1_context *ctx, uchar *input, uint length )
+{
+    ulong left, fill;
+
+    if( ! length ) return;
+
+    left = ctx->total[0] & 0x3F;
+    fill = 64 - left;
+
+    ctx->total[0] += length;
+    ctx->total[0] &= 0xFFFFFFFF;
+
+    if( ctx->total[0] < length )
+        ctx->total[1]++;
+
+    if( left && length >= fill )
+    {
+        memcpy( (void *) (ctx->buffer + left),
+                (void *) input, fill );
+        sha1_process( ctx, ctx->buffer );
+        length -= fill;
+        input  += fill;
+        left = 0;
+    }
+
+    while( length >= 64 )
+    {
+        sha1_process( ctx, input );
+        length -= 64;
+        input  += 64;
+    }
+
+    if( length )
+    {
+        memcpy( (void *) (ctx->buffer + left),
+                (void *) input, length );
+    }
+}
+
+static uchar sha1_padding[64] =
+{
+ 0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
+};
+
+void sha1_finish( sha1_context *ctx, uchar digest[20] )
+{
+    ulong last, padn;
+    ulong high, low;
+    uchar msglen[8];
+
+    high = ( ctx->total[0] >> 29 )
+         | ( ctx->total[1] <<  3 );
+    low  = ( ctx->total[0] <<  3 );
+
+    PUT_UINT32_BE( high, msglen, 0 );
+    PUT_UINT32_BE( low,  msglen, 4 );
+
+    last = ctx->total[0] & 0x3F;
+    padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );
+
+    sha1_update( ctx, sha1_padding, padn );
+    sha1_update( ctx, msglen, 8 );
+
+    PUT_UINT32_BE( ctx->state[0], digest,  0 );
+    PUT_UINT32_BE( ctx->state[1], digest,  4 );
+    PUT_UINT32_BE( ctx->state[2], digest,  8 );
+    PUT_UINT32_BE( ctx->state[3], digest, 12 );
+    PUT_UINT32_BE( ctx->state[4], digest, 16 );
+}
+
+/*
+ * Output SHA-1(file contents), returns 0 if successful.
+ */
+int sha1_file( char *filename, uchar digest[20] )
+{
+    FILE *f;
+    size_t n;
+    sha1_context ctx;
+    uchar buf[1024];
+
+    if( ( f = fopen( filename, "rb" ) ) == NULL )
+        return( 1 );
+
+    sha1_starts( &ctx );
+
+    while( ( n = fread( buf, 1, sizeof( buf ), f ) ) > 0 )
+        sha1_update( &ctx, buf, (uint) n );
+
+    sha1_finish( &ctx, digest );
+
+    fclose( f );
+    return( 0 );
+}
+
+/*
+ * Output SHA-1(buf)
+ */
+void sha1_csum( uchar *buf, uint buflen, uchar digest[20] )
+{
+    sha1_context ctx;
+
+    sha1_starts( &ctx );
+    sha1_update( &ctx, buf, buflen );
+    sha1_finish( &ctx, digest );
+}
+
+/*
+ * Output HMAC-SHA-1(key,buf)
+ */
+void sha1_hmac( uchar *key, uint keylen, uchar *buf, uint buflen,
+                uchar digest[20] )
+{
+    uint i;
+    sha1_context ctx;
+    uchar k_ipad[64];
+    uchar k_opad[64];
+    uchar tmpbuf[20];
+
+    memset( k_ipad, 0x36, 64 );
+    memset( k_opad, 0x5C, 64 );
+
+    for( i = 0; i < keylen; i++ )
+    {
+        if( i >= 64 ) break;
+
+        k_ipad[i] ^= key[i];
+        k_opad[i] ^= key[i];
+    }
+
+    sha1_starts( &ctx );
+    sha1_update( &ctx, k_ipad, 64 );
+    sha1_update( &ctx, buf, buflen );
+    sha1_finish( &ctx, tmpbuf );
+
+    sha1_starts( &ctx );
+    sha1_update( &ctx, k_opad, 64 );
+    sha1_update( &ctx, tmpbuf, 20 );
+    sha1_finish( &ctx, digest );
+
+    memset( k_ipad, 0, 64 );
+    memset( k_opad, 0, 64 );
+    memset( tmpbuf, 0, 20 );
+    memset( &ctx, 0, sizeof( sha1_context ) );
+}
+
+#ifdef SELF_TEST
+/*
+ * FIPS-180-1 test vectors
+ */
+static char *sha1_test_str[3] =
+{
+    "abc",
+    "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq",
+    NULL
+};
+
+static uchar sha1_test_sum[3][20] =
+{
+    { 0xA9, 0x99, 0x3E, 0x36, 0x47, 0x06, 0x81, 0x6A, 0xBA, 0x3E,
+      0x25, 0x71, 0x78, 0x50, 0xC2, 0x6C, 0x9C, 0xD0, 0xD8, 0x9D },
+    { 0x84, 0x98, 0x3E, 0x44, 0x1C, 0x3B, 0xD2, 0x6E, 0xBA, 0xAE,
+      0x4A, 0xA1, 0xF9, 0x51, 0x29, 0xE5, 0xE5, 0x46, 0x70, 0xF1 },
+    { 0x34, 0xAA, 0x97, 0x3C, 0xD4, 0xC4, 0xDA, 0xA4, 0xF6, 0x1E,
+      0xEB, 0x2B, 0xDB, 0xAD, 0x27, 0x31, 0x65, 0x34, 0x01, 0x6F }
+};
+
+/*
+ * Checkup routine
+ */
+int sha1_self_test( void )
+{
+    int i, j;
+    uchar buf[1000];
+    uchar sha1sum[20];
+    sha1_context ctx;
+
+    for( i = 0; i < 3; i++ )
+    {
+        printf( "  SHA-1 test #%d: ", i + 1 );
+
+        sha1_starts( &ctx );
+
+        if( i < 2 )
+            sha1_update( &ctx, (uchar *) sha1_test_str[i],
+                         strlen( sha1_test_str[i] ) );
+        else
+        {
+            memset( buf, 'a', 1000 );
+            for( j = 0; j < 1000; j++ )
+                sha1_update( &ctx, (uchar *) buf, 1000 );
+        }
+
+        sha1_finish( &ctx, sha1sum );
+
+        if( memcmp( sha1sum, sha1_test_sum[i], 20 ) != 0 )
+        {
+            printf( "failed\n" );
+            return( 1 );
+        }
+
+        printf( "passed\n" );
+    }
+
+    printf( "\n" );
+    return( 0 );
+}
+#else
+int sha1_self_test( void )
+{
+    printf( "SHA-1 self-test not available\n\n" );
+    return( 1 );
+}
+#endif
+
+
--- /dev/null
+++ b/src/ap/sha1.h
@@ -0,0 +1,59 @@
+#ifndef _SHA1_H
+#define _SHA1_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef _STD_TYPES
+#define _STD_TYPES
+
+#define uchar   unsigned char
+#define uint    unsigned int
+#define ulong   unsigned long int
+
+#endif
+
+typedef struct
+{
+    ulong total[2];
+    ulong state[5];
+    uchar buffer[64];
+}
+sha1_context;
+
+/*
+ * Core SHA-1 functions
+ */
+void sha1_starts( sha1_context *ctx );
+void sha1_update( sha1_context *ctx, uchar *input, uint length );
+void sha1_finish( sha1_context *ctx, uchar digest[20] );
+
+/*
+ * Output SHA-1(file contents), returns 0 if successful.
+ */
+int sha1_file( char *filename, uchar digest[20] );
+
+/*
+ * Output SHA-1(buf)
+ */
+void sha1_csum( uchar *buf, uint buflen, uchar digest[20] );
+
+/*
+ * Output HMAC-SHA-1(key,buf)
+ */
+void sha1_hmac( uchar *key, uint keylen, uchar *buf, uint buflen,
+                uchar digest[20] );
+
+/*
+ * Checkup routine
+ */
+int sha1_self_test( void );
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* sha1.h */
+
+
